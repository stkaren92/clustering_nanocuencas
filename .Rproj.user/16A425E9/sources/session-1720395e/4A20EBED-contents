# Util funcs ----

calculate_similarity_matrix <- function(script_path, funcion='similarity_matrix', ...) {
  env <- new.env()  # Crea un entorno aislado
  sys.source(script_path, env)  # Carga el script en el entorno seguro
  
  if (exists(funcion, envir = env)) {  # Verifica si la función está definida en el entorno
    return(do.call(get(funcion, envir = env), list(...)))  # Ejecuta la función en el entorno seguro
  } else {
    stop("La función no se encontró en el script.")
  }
}

#' Calculate recall@Recall for the top k retrieved items

#' @param pred A data frame containing predicted plant-bee interactions.
#' @param obs  A matrix containing observed plant-bee interactions.
#' @param k    An integer specifying the number of top interactions to retrieve.

#' @return The ratio of observed interactions found within the top k retrieved
#'         predictions.
get_recall_at <- function(pred, obs, k) {
  df_top_k <- pred %>%
    group_by(bee) %>%
    slice_max(order_by = score, n = k, with_ties = T)
  
  obs <- as.data.frame(obs)
  obs$X <- rownames(obs)
  
  observed_int <- obs %>%
    pivot_longer(-X, names_to = "bee", values_to = "counts") %>%
    filter(counts > 0)
  
  df_acc <- df_top_k %>%
    right_join(observed_int, by = join_by(plant == X, bee))
  
  sum(!is.na(df_acc$score)) / nrow(df_acc)
}


get_recall_k <- function(pred, obs, k) {
  
  pred <- data.frame(plant = rownames(pred), 
                                  as.data.frame(pred)) %>% 
    pivot_longer( 
      cols = -plant,
      names_to = "bee",
      values_to = "score"
    )
  
  df_top_k <- pred %>%
    group_by(bee) %>%
    slice_max(order_by = score, n = k, with_ties = T)
  
  obs <- as.data.frame(obs)
  obs$X <- rownames(obs)
  
  observed_int <- obs %>%
    pivot_longer(-X, names_to = "bee", values_to = "counts") %>%
    filter(counts > 0)
  
  df_acc <- df_top_k %>%
    right_join(observed_int, by = join_by(plant == X, bee))
  
  sum(!is.na(df_acc$score)) / nrow(df_acc)
}

get_k_matrix <- function(scores, k){
  df_recommendation <- data.frame(plant = rownames(scores), 
                                  as.data.frame(scores)) %>% 
    pivot_longer( 
      cols = -plant,
      names_to = "bee",
      values_to = "score"
    )
  interaction_matrix_scores <- df_recommendation %>%
    group_by(bee) %>%
    slice_max(order_by = score, n = k, with_ties = T) %>%
    pivot_wider(id_cols = plant, names_from = bee, values_from = score,
                values_fill = 0)
  
  # Add plants not recommended
  interaction_matrix_scores <- bind_rows(interaction_matrix_scores,
                                         data.frame(plant = setdiff(
                                           unique(df_recommendation$plant),
                                           interaction_matrix_scores$plant))) %>% 
    replace(is.na(.), 0) %>% 
    arrange(plant)
  
  # Create matrix with 0 and 1's
  interaction_matrix_predicted <- interaction_matrix_scores %>% 
    mutate_if(is.numeric, 
              ~ case_when(
                .x != 0 ~ 1,
                .x == 0 ~ 0)
    )
  return(interaction_matrix_predicted)
}

get_cs_plants_scores <- function(model.w.sideinfo,
                                 names_bees,
                                 Y_cs_plants){
  n_bees <- length(names_bees)
  recommendation_matrix_cs <- matrix(1, nrow = n_bees, ncol = nrow(Y_cs_plants))
  for(b in 1:n_bees){
    for(p in 1:nrow(Y_cs_plants)) {
      score <- predict_new_items(model.w.sideinfo, 
                                 user=b,
                                 I=Y_cs_plants[p,])
      recommendation_matrix_cs[b,p] <- score
    }
    cat(sprintf("\rProgreso: %.1f%%", round((b / n_bees) * 100, 1)))  # Imprime el progreso en la misma línea
    flush.console()  # Asegura que se actualice en RStudio
  }
  rownames(recommendation_matrix_cs) <- names_bees
  colnames(recommendation_matrix_cs) <- rownames(Y_cs_plants)
  
  return(recommendation_matrix_cs)
}


get_fold <- function(R, k_folds) {
  
  # Convert to long dataframe and 
  # filter bees with interaction with more than one plant  
  df_Rtest <- as.data.frame(R) %>%  
    tibble::rownames_to_column("plant_spe_id") %>% 
    pivot_longer(!plant_spe_id, 
                 names_to = "bee_spe_id", 
                 values_to = "interaction") %>% 
    group_by(bee_spe_id) %>% 
    mutate(n = sum(interaction != 0)) %>% 
    filter(interaction > 0 & n > 1) %>%  
    select(!n)
  
  folds <- createFolds(df_Rtest$plant_spe_id, k = k_folds)
  fold_list<- list()
  for(i in 1:k_folds) {
    print(i)
    
    sample <- unlist(folds[i])
    Rtest <- df_Rtest[sample, ]
    
    # Convert to wide dataframe
    Rtest <- Rtest %>% 
      pivot_wider(names_from = "bee_spe_id", 
                  values_from = "interaction") %>%  
      replace(is.na(.), 0) 
    
    # Add missing plants and bees 
    Rtest <- bind_rows(Rtest,
                       data.frame(plant_spe_id = setdiff(
                         rownames(R),
                         Rtest$plant_spe_id))) %>%
      arrange(match(plant_spe_id, rownames(R)))
    missing_col <- setdiff(colnames(R), names(Rtest))
    Rtest[missing_col] <- 0   
    Rtest <- Rtest[c('plant_spe_id',colnames(R))]
    
    # Convert to matrix
    Rtest <- Rtest %>%  
      replace(is.na(.), 0) %>% 
      column_to_rownames(var = "plant_spe_id") %>%
      as.matrix()
    
    # Get training
    Rtrain <- R - Rtest
    
    fold_list[[i]] <- list("Rtrain" = Rtrain, "Rtest" =Rtest)
  }
  return(fold_list)
}



split_R <- function(R, test_size) {
  test_size <- floor(test_size*sum(R>0))
  print(test_size)
  
  # Convert to long dataframe and 
  # filter bees with interaction with more than one plant  
  Rtest_w <- as.data.frame(R) %>%  
    tibble::rownames_to_column("plant_spe_id") %>% 
    pivot_longer(!plant_spe_id, 
                 names_to = "bee_spe_id", 
                 values_to = "interaction") %>% 
    group_by(bee_spe_id) %>% 
    mutate(n_bee = sum(interaction != 0)) %>% 
    ungroup() %>% 
    group_by(plant_spe_id) %>% 
    mutate(n_plant = sum(interaction != 0)) %>% 
    filter(interaction > 0 & n_bee > 1 & n_plant > 1) %>%   
    select(-c(n_bee,n_plant))
  
  # Select interactions at random for testing
  sample <- sample.int(n = nrow(Rtest_w), size = test_size, 
                       replace = F)
  Rtest_w <- Rtest_w[sample, ]
  
  # Convert to wide dataframe
  Rtest_w <- Rtest_w %>% 
    pivot_wider(names_from = "bee_spe_id", 
                values_from = "interaction") %>%  
    replace(is.na(.), 0) 
  
  # Add missing plants and bees 
  Rtest_w <- bind_rows(Rtest_w,
                     data.frame(plant_spe_id = setdiff(
                       rownames(R),
                       Rtest_w$plant_spe_id))) %>%
    arrange(match(plant_spe_id, rownames(R)))
  missing_col <- setdiff(colnames(R), names(Rtest_w))
  Rtest_w[missing_col] <- 0   
  Rtest_w <- Rtest_w[c('plant_spe_id',colnames(R))]
  
  # Convert to matrix
  Rtest_w <- Rtest_w %>%  
    replace(is.na(.), 0) %>% 
    column_to_rownames(var = "plant_spe_id") %>%
    as.matrix()
  
  Rtest_w <- Rtest_w[rownames(R),] #sort names
  Rtest_w <- Rtest_w[,colnames(R)] #sort names
  
  # Get training
  Rtrain <- R - Rtest_w
  
  return(list(Rtest = Rtest_w, Rtrain = Rtrain))
  
}


split_R_cs <- function(R, test_size, n_cs_plants) {
  test_size <- floor(test_size*sum(R>0))
  print(test_size)
  
  # Convert to long dataframe and 
  # filter bees and plants with more than one interaction  
  Rtest_w <- as.data.frame(R) %>%  
    tibble::rownames_to_column("plant_spe_id") %>% 
    pivot_longer(!plant_spe_id, 
                 names_to = "bee_spe_id", 
                 values_to = "interaction") %>% 
    group_by(bee_spe_id) %>% 
    mutate(n_bee = sum(interaction != 0)) %>% 
    ungroup() %>% 
    group_by(plant_spe_id) %>% 
    mutate(n_plant = sum(interaction != 0)) %>% 
    filter(interaction > 0 & n_bee > 1 & n_plant > 1) %>%   
    select(-c(n_bee,n_plant))
  
  # Select interactions at random for testing
  sample <- sample.int(n = nrow(Rtest_w), size = test_size, 
                       replace = F)
  Rtest_w <- Rtest_w[sample, ]
  
  # Convert to wide dataframe
  Rtest_w <- Rtest_w %>% 
    pivot_wider(names_from = "bee_spe_id", 
                values_from = "interaction") %>%  
    replace(is.na(.), 0) 
  
  # Add missing plants and bees 
  Rtest_w <- bind_rows(Rtest_w,
                       data.frame(plant_spe_id = setdiff(
                         rownames(R),
                         Rtest_w$plant_spe_id))) %>%
    arrange(match(plant_spe_id, rownames(R)))
  missing_col <- setdiff(colnames(R), names(Rtest_w))
  Rtest_w[missing_col] <- 0   
  Rtest_w <- Rtest_w[c('plant_spe_id',colnames(R))]
  
  # Convert to matrix
  Rtest_w <- Rtest_w %>%  
    replace(is.na(.), 0) %>% 
    column_to_rownames(var = "plant_spe_id") %>%
    as.matrix()
  
  Rtest_w <- Rtest_w[rownames(R),] #sort names
  Rtest_w <- Rtest_w[,colnames(R)] #sort names
  
  # Get training
  Rtrain <- R - Rtest_w
  
  # Get cold start
  Rtest_cs <- as.data.frame(Rtrain) %>%  
    tibble::rownames_to_column("plant_spe_id") %>% 
    pivot_longer(!plant_spe_id, 
                 names_to = "bee_spe_id", 
                 values_to = "interaction")
  
  # Select plants at random for testing cold start
  cs_sample_plants <- unique(Rtest_cs$plant_spe_id)
  sample <- sample.int(n = length(cs_sample_plants), size = n_cs_plants, 
                       replace = F)
  Rtest_cs <- Rtest_cs %>% 
    filter(plant_spe_id %in% cs_sample_plants[sample])
  
  # Convert to wide dataframe
  Rtest_cs <- Rtest_cs %>% 
    pivot_wider(names_from = "bee_spe_id", 
                values_from = "interaction") %>%  
    replace(is.na(.), 0) 
  
  # Add missing plants and bees 
  Rtest_cs <- bind_rows(Rtest_cs,
                       data.frame(plant_spe_id = setdiff(
                         rownames(R),
                         Rtest_cs$plant_spe_id))) %>%
    arrange(match(plant_spe_id, rownames(R)))
  missing_col <- setdiff(colnames(R), names(Rtest_cs))
  Rtest_cs[missing_col] <- 0   
  Rtest_cs <- Rtest_cs[c('plant_spe_id',colnames(R))]
  
  # Convert to matrix
  Rtest_cs <- Rtest_cs %>%  
    replace(is.na(.), 0) %>% 
    column_to_rownames(var = "plant_spe_id") %>%
    as.matrix()
  
  Rtest_cs <- Rtest_cs[rownames(R),] #sort names
  Rtest_cs <- Rtest_cs[,colnames(R)] #sort names
  
  # Get training
  Rtrain <- R - Rtest_w - Rtest_cs
  
  return(list(Rtest_w = Rtest_w, Rtest_cs = Rtest_cs, Rtrain = Rtrain))
  
}

get_fold_cs <- function(R, k_folds, n_cs_plants=2) {
  
  # Convert to long dataframe and 
  # filter bees with interaction with more than one plant  
  df_Rtest <- as.data.frame(R) %>%  
    tibble::rownames_to_column("plant_spe_id") %>% 
    pivot_longer(!plant_spe_id, 
                 names_to = "bee_spe_id", 
                 values_to = "interaction") %>% 
    group_by(bee_spe_id) %>% 
    mutate(n_bee = sum(interaction != 0)) %>% 
    ungroup() %>% 
    group_by(plant_spe_id) %>% 
    mutate(n_plant = sum(interaction != 0)) %>% 
    filter(interaction > 0 & n_bee > 1 & n_plant > 1) %>%   
    select(-c(n_bee,n_plant))
  
  folds <- createFolds(df_Rtest$plant_spe_id, k = k_folds)
  fold_list<- list()
  for(i in 1:k_folds) {
    print(i)
    
    sample <- unlist(folds[i])
    Rtest <- df_Rtest[sample, ]
    
    # Convert to wide dataframe
    Rtest <- Rtest %>% 
      pivot_wider(names_from = "bee_spe_id", 
                  values_from = "interaction") %>%  
      replace(is.na(.), 0) 
    
    # Add missing plants and bees 
    Rtest <- bind_rows(Rtest,
                       data.frame(plant_spe_id = setdiff(
                         rownames(R),
                         Rtest$plant_spe_id))) %>%
      arrange(match(plant_spe_id, rownames(R)))
    missing_col <- setdiff(colnames(R), names(Rtest))
    Rtest[missing_col] <- 0   
    Rtest <- Rtest[c('plant_spe_id',colnames(R))]
    
    # Convert to matrix
    Rtest <- Rtest %>%  
      replace(is.na(.), 0) %>% 
      column_to_rownames(var = "plant_spe_id") %>%
      as.matrix()
    
    Rtest <- Rtest[rownames(R),] #sort names
    Rtest <- Rtest[,colnames(R)] #sort names
    
    # Get training
    Rtrain <- R - Rtest
    
    # Get cold start
    Rtest_cs <- as.data.frame(Rtrain) %>%  
      tibble::rownames_to_column("plant_spe_id") %>% 
      pivot_longer(!plant_spe_id, 
                   names_to = "bee_spe_id", 
                   values_to = "interaction")
    
    # Select plants at random for testing cold start
    cs_sample_plants <- unique(Rtest_cs$plant_spe_id)
    sample <- sample.int(n = length(cs_sample_plants), size = n_cs_plants, 
                         replace = F)
    Rtest_cs <- Rtest_cs %>% 
      filter(plant_spe_id %in% cs_sample_plants[sample])
    
    # Convert to wide dataframe
    Rtest_cs <- Rtest_cs %>% 
      pivot_wider(names_from = "bee_spe_id", 
                  values_from = "interaction") %>%  
      replace(is.na(.), 0) 
    
    # Add missing plants and bees 
    Rtest_cs <- bind_rows(Rtest_cs,
                          data.frame(plant_spe_id = setdiff(
                            rownames(R),
                            Rtest_cs$plant_spe_id))) %>%
      arrange(match(plant_spe_id, rownames(R)))
    missing_col <- setdiff(colnames(R), names(Rtest_cs))
    Rtest_cs[missing_col] <- 0   
    Rtest_cs <- Rtest_cs[c('plant_spe_id',colnames(R))]
    
    # Convert to matrix
    Rtest_cs <- Rtest_cs %>%  
      replace(is.na(.), 0) %>% 
      column_to_rownames(var = "plant_spe_id") %>%
      as.matrix()
    
    Rtest_cs <- Rtest_cs[rownames(R),] #sort names
    Rtest_cs <- Rtest_cs[,colnames(R)] #sort names
    
    # Get training
    Rtrain <- R - Rtest - Rtest_cs
    
    fold_list[[i]] <- list("Rtrain" = Rtrain, 
                           "Rtest" = Rtest,
                           "Rtest_cs" = Rtest_cs)
  }
  return(fold_list)
}